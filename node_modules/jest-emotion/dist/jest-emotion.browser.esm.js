import chalk from 'chalk';
import { stringify, parse } from 'css';

function defaultClassNameReplacer(className, index) {
  return "emotion-" + index;
}

var componentSelectorClassNamePattern = /^e[a-zA-Z0-9]+[0-9]+$/;
var replaceClassNames = function replaceClassNames(classNames, styles, code, keys, classNameReplacer) {
  if (classNameReplacer === void 0) {
    classNameReplacer = defaultClassNameReplacer;
  }

  var index = 0;
  var keyPattern = new RegExp("^(" + keys.join('|') + ")-");
  return classNames.reduce(function (acc, className) {
    if (keyPattern.test(className) || componentSelectorClassNamePattern.test(className)) {
      var escapedRegex = new RegExp(className.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&'), 'g');
      return acc.replace(escapedRegex, classNameReplacer(className, index++));
    }

    return acc;
  }, "" + styles + (styles ? '\n\n' : '') + code);
};

var RULE_TYPES = {
  media: 'media',
  rule: 'rule'
};

function getClassNames(selectors, classes) {
  return classes ? selectors.concat(classes.split(' ')) : selectors;
}

function getClassNamesFromTestRenderer(selectors, _ref) {
  var _ref$props = _ref.props,
      props = _ref$props === void 0 ? {} : _ref$props;
  return getClassNames(selectors, props.className || props.class);
}

function shouldDive(node) {
  return typeof node.dive === 'function' && typeof node.type() !== 'string';
}

function isTagWithClassName(node) {
  return node.prop('className') && typeof node.type() === 'string';
}

function getClassNamesFromEnzyme(selectors, node) {
  // We need to dive if we have selected a styled child from a shallow render
  var actualComponent = shouldDive(node) ? node.dive() : node; // Find the first node with a className prop

  var components = actualComponent.findWhere(isTagWithClassName);
  var classes = components.length && components.first().prop('className');
  return getClassNames(selectors, classes);
}

function getClassNamesFromCheerio(selectors, node) {
  var classes = node.attr('class');
  return getClassNames(selectors, classes);
}

function getClassNamesFromDOMElement(selectors, node) {
  return getClassNames(selectors, node.getAttribute('class'));
}

function isReactElement(val) {
  return val.$$typeof === Symbol.for('react.test.json');
}
var domElementPattern = /^((HTML|SVG)\w*)?Element$/;
function isDOMElement(val) {
  return val.nodeType === 1 && val.constructor && val.constructor.name && domElementPattern.test(val.constructor.name);
}

function isEnzymeElement(val) {
  return typeof val.findWhere === 'function';
}

function isCheerioElement(val) {
  return val.cheerio === '[cheerio object]';
}

function getClassNamesFromNodes(nodes) {
  return nodes.reduce(function (selectors, node) {
    if (isReactElement(node)) {
      return getClassNamesFromTestRenderer(selectors, node);
    } else if (isEnzymeElement(node)) {
      return getClassNamesFromEnzyme(selectors, node);
    } else if (isCheerioElement(node)) {
      return getClassNamesFromCheerio(selectors, node);
    }

    return getClassNamesFromDOMElement(selectors, node);
  }, []);
}
var keyframesPattern = /^@keyframes\s+(animation-[^{\s]+)+/;
var removeCommentPattern = /\/\*[\s\S]*?\*\//g;
function getStylesFromClassNames(classNames, elements) {
  if (!classNames.length) {
    return '';
  }

  var keys = getKeys(elements);

  if (!keys.length) {
    return '';
  }

  var keyPatten = new RegExp("^(" + keys.join('|') + ")-");
  var filteredClassNames = classNames.filter(function (className) {
    return keyPatten.test(className);
  });

  if (!filteredClassNames.length) {
    return '';
  }

  var selectorPattern = new RegExp('\\.(' + filteredClassNames.join('|') + ')');
  var keyframes = {};
  var styles = '';
  elements.forEach(function (element) {
    var rule = element.textContent || '';

    if (selectorPattern.test(rule)) {
      styles += rule;
    }

    var match = rule.match(keyframesPattern);

    if (match !== null) {
      var name = match[1];

      if (keyframes[name] === undefined) {
        keyframes[name] = '';
      }

      keyframes[name] += rule;
    }
  });
  var keyframeNameKeys = Object.keys(keyframes);
  var keyframesStyles = '';

  if (keyframeNameKeys.length) {
    var keyframesNamePattern = new RegExp(keyframeNameKeys.join('|'), 'g');
    var keyframesNameCache = {};
    var index = 0;
    styles = styles.replace(keyframesNamePattern, function (name) {
      if (keyframesNameCache[name] === undefined) {
        keyframesNameCache[name] = "animation-" + index++;
        keyframesStyles += keyframes[name];
      }

      return keyframesNameCache[name];
    });
    keyframesStyles = keyframesStyles.replace(keyframesNamePattern, function (value) {
      return keyframesNameCache[value];
    });
  }

  return (keyframesStyles + styles).replace(removeCommentPattern, '');
}
function getStyleElements() {
  var elements = Array.from(document.querySelectorAll('style[data-emotion]')); // $FlowFixMe

  return elements;
}

var unique = function unique(arr) {
  return Array.from(new Set(arr));
};

function getKeys(elements) {
  var keys = unique(elements.map(function (element) {
    return (// $FlowFixMe we know it exists since we query for elements with this attribute
      element.getAttribute('data-emotion')
    );
  })).filter(Boolean);
  return keys;
}
function hasClassNames(classNames, selectors, target) {
  // selectors is the classNames of specific css rule
  return selectors.some(function (selector) {
    // if no target, use className of the specific css rule and try to find it
    // in the list of received node classNames to make sure this css rule
    // applied for root element
    if (!target) {
      return classNames.includes(selector.slice(1));
    } // check if selector (className) of specific css rule match target


    return selector.includes(target);
  });
}
function getMediaRules(rules, media) {
  return rules.filter(function (rule) {
    var isMediaMatch = rule.media ? rule.media.replace(/\s/g, '').includes(media.replace(/\s/g, '')) : false;
    return rule.type === RULE_TYPES.media && isMediaMatch;
  }).reduce(function (mediaRules, mediaRule) {
    return mediaRules.concat(mediaRule.rules);
  }, []);
}

/*
 * Taken from
 * https://github.com/facebook/jest/blob/be4bec387d90ac8d6a7596be88bf8e4994bc3ed9/packages/expect/src/jasmine_utils.js#L234
 */

function isA(typeName, value) {
  return Object.prototype.toString.apply(value) === "[object " + typeName + "]";
}
/*
 * Taken from
 * https://github.com/facebook/jest/blob/be4bec387d90ac8d6a7596be88bf8e4994bc3ed9/packages/expect/src/jasmine_utils.js#L36
 */


function isAsymmetric(obj) {
  return obj && isA('Function', obj.asymmetricMatch);
}

function valueMatches(declaration, value) {
  if (value instanceof RegExp) {
    return value.test(declaration.value);
  }

  if (isAsymmetric(value)) {
    return value.asymmetricMatch(declaration.value);
  }

  return value === declaration.value;
}

function toHaveStyleRule(received, property, value, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      target = _options.target,
      media = _options.media;
  var classNames = getClassNamesFromNodes([received]);
  var cssString = getStylesFromClassNames(classNames, getStyleElements());
  var styles = parse(cssString);
  var preparedRules = styles.stylesheet.rules;

  if (media) {
    preparedRules = getMediaRules(preparedRules, media);
  }

  var declaration = preparedRules.filter(function (rule) {
    return rule.type === RULE_TYPES.rule && hasClassNames(classNames, rule.selectors, target);
  }).reduce(function (decs, rule) {
    return decs.concat(rule.declarations);
  }, []).filter(function (dec) {
    return dec.type === 'declaration' && dec.property === property;
  }).pop();

  if (!declaration) {
    return {
      pass: false,
      message: function message() {
        return "Property not found: " + property;
      }
    };
  }

  var pass = valueMatches(declaration, value);

  var message = function message() {
    return "Expected " + property + (pass ? ' not ' : ' ') + "to match:\n" + ("  " + chalk.green(value) + "\n") + 'Received:\n' + ("  " + chalk.red(declaration.value));
  };

  return {
    pass: pass,
    message: message
  };
}

var matchers = {
  toHaveStyleRule: toHaveStyleRule
};

function getNodes(node, nodes) {
  if (nodes === void 0) {
    nodes = [];
  }

  if (node.children) {
    for (var _iterator = node.children, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var child = _ref;
      getNodes(child, nodes);
    }
  }

  if (typeof node === 'object') {
    nodes.push(node);
  }

  return nodes;
}

function getPrettyStylesFromClassNames(classNames, elements) {
  var styles = getStylesFromClassNames(classNames, elements);
  var prettyStyles;

  try {
    prettyStyles = stringify(parse(styles));
  } catch (e) {
    console.error(e);
    throw new Error("There was an error parsing the following css: \"" + styles + "\"");
  }

  return prettyStyles;
}

function createSerializer(_temp) {
  var _ref2 = _temp === void 0 ? {} : _temp,
      classNameReplacer = _ref2.classNameReplacer,
      _ref2$DOMElements = _ref2.DOMElements,
      DOMElements = _ref2$DOMElements === void 0 ? true : _ref2$DOMElements;

  var cache = new WeakSet();

  function print(val, printer) {
    var nodes = getNodes(val);
    var classNames = getClassNamesFromNodes(nodes);
    var elements = getStyleElements();
    var styles = getPrettyStylesFromClassNames(classNames, elements);
    nodes.forEach(cache.add, cache);
    var printedVal = printer(val);
    nodes.forEach(cache.delete, cache);
    var keys = getKeys(elements);
    return replaceClassNames(classNames, styles, printedVal, keys, classNameReplacer);
  }

  function test(val) {
    return val && !cache.has(val) && (isReactElement(val) || DOMElements && isDOMElement(val));
  }

  return {
    test: test,
    print: print
  };
}

var _createSerializer = createSerializer(),
    print = _createSerializer.print,
    test = _createSerializer.test;
var index = {
  print: print,
  test: test
};

export default index;
export { createSerializer, print, test, matchers };
